<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="/kbarchive/assets/css/style.css?v=d2057ae472d963fbdcbf65805f43123bccb709dc">
    <link rel="stylesheet" type="text/css" href="/kbarchive/assets/css/print.css" media="print">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Q41247: Use Huge Pointers If Object Is Larger Than 64K Boundary | KnowledgeBase Archive</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Q41247: Use Huge Pointers If Object Is Larger Than 64K Boundary" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="An Archive of Early Microsoft KnowledgeBase Articles" />
<meta property="og:description" content="An Archive of Early Microsoft KnowledgeBase Articles" />
<link rel="canonical" href="http://jeffpar.github.io/kbarchive/kb/041/Q41247/" />
<meta property="og:url" content="http://jeffpar.github.io/kbarchive/kb/041/Q41247/" />
<meta property="og:site_name" content="KnowledgeBase Archive" />
<script type="application/ld+json">
{"headline":"Q41247: Use Huge Pointers If Object Is Larger Than 64K Boundary","url":"http://jeffpar.github.io/kbarchive/kb/041/Q41247/","description":"An Archive of Early Microsoft KnowledgeBase Articles","@type":"WebPage","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body>
<div id="container">
    <div class="inner">

        <header>
            <h1><a href="/kbarchive">KnowledgeBase Archive</a></h1>
            <h2>An Archive of Early Microsoft KnowledgeBase Articles</h2>
        </header>
        <section id="downloads" class="clearfix">
            
            
            <a href="https://github.com/jeffpar/kbarchive" id="view-on-github" class="button"><span>View on GitHub</span></a>
            
        </section>
        <hr>
        <section id="main_content">
                <div>
        <h2 id="q41247-use-huge-pointers-if-object-is-larger-than-64k-boundary">Q41247: Use Huge Pointers If Object Is Larger Than 64K Boundary</h2>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Article: Q41247
Product(s): See article
Version(s): 5.10
Operating System(s): OS/2
Keyword(s): ENDUSER | SR# G890201-11081 | mspl13_c
Last Modified: 16-MAY-1989

Question:

I'm declaring a pointer that points into an array by saying the
following:

  char huge carray[70000];
  char *pchar = carray;

I compile the program using large-memory model.

When I access the array using carray, everything work correctly.
However, when I use the pointer pchar, I can't seem to access the
array past the 64K boundary. What's wrong?

Response:

The problem is caused by using a far pointer in a situation where you
need a huge pointer.

There are three types of data pointers in Microsoft C: near, far, and
huge. Near pointers represent offsets within DGROUP (the default data
segment) and are stored in 2 bytes. Far and huge pointers contain both
a segment address/selector and an offset and therefore take 4 bytes.

Although far and huge pointers are identical in format, the algorithms
used to do addressing calculations involving these two types of
pointers are very different. Far pointers are assumed to point to a
data item that does not cross a segment boundary (in other words, the
size of the item must be less than 64K). As a result, the compiler
ignores the segment part of the pointer in all calculations except for
"equals" and "not equals" tests. This gives a considerable (more than
2 times) savings in execution time for these operations. In fact,
calculations involving far pointers are almost as fast as calculations
involving near pointers.

Huge pointers may point to items that are larger than 64K. The
addressing arithmetic work on both the segment and the offset, if
necessary. Huge pointer arithmetic is therefore considerably slower
than far arithmetic, but it has the advantage of working when the data
item is larger than 64K.

Your code should work correctly if you declare pchar to be a huge
pointer rather than a far (default for large-memory model) pointer. If
you didn't want to add the huge keyword to the declaration, you could
compile with the /AH option. It is recommended to use the huge keyword
rather than /AH because it allows you to control when huge arithmetic
is performed -- if you use /AH, then ALL pointers are huge.
</code></pre></div></div>


        <p>
            THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
            ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
            OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
            EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
            ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
            CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
            MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
            POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
            OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
            SO THE FOREGOING LIMITATION MAY NOT APPLY.
        </p>
        <p>Copyright Microsoft Corporation 1986-2002.</p>
    </div>

        </section>

        <footer>
            
            KnowledgeBase Archive is maintained by <a href="https://www.pcjs.org">PCjs</a>.<br>
            
            This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.
        </footer>

    </div>
</div>


<script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-49658648-3', 'auto');
    ga('send', 'pageview');
</script>

</body>
</html>